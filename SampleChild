package g_oop2;

public class SampleChild extends SampleParent {
//생성자와 초기화 블록을 제외한 SampleParent 가져다 쓴다.

	
	void childMethod(){
		System.out.println(var); //상속받은 변수
		System.out.println(method (7,3)); //상속받은 메소드
	} 

	//1) 오버라이딩 - 메소드 상속받았지만 내용을 변경하고 싶을 경우(내용 재정의)
	@Override//어노테이션: 클래스,변수,메소드 등에 표시해 놓을 것.
	int method(int a, int b){ //리턴타입 메소드 명과 파라미터 명이 모두 같아야한다
		return a * b; //원하는 내용으로 내용변경
	}
	
	
	//super, super() -부모클래스 자식클래스 이름 구별하기 위해 super 사용 
	// cf. this 생성자에서 다른생성자 호출 super는 자식클래스에서 부모클래스생성자 사용할 때
	//다형성 - 다양한 형태를 가지는 것
	
	
	//super,super() 1.지역변수가 우선(파라미터우선)
 	int var; //안스턴스변수
	void test(double var){ //지역변수
		System.out.println(var);
		System.out.println(this.var);//인스턴스변수 
		System.out.println(super.var);//부모클래스의 인스턴스 변수
		//super: 부모 클래스의 자식 클래스의 멤버가 이름이 중복될 때 둘을 구분(변수뿐 아니라 메소드도 구분)하기 위해 사용한다.

		System.out.println(this.method(10,20));  //this는 overriding한 메소드
		System.out.println(super.method(10,20)); //super는 부모클래스의 메소드 
	}

	//super()
	SampleChild(){
		super(); //자식클래스의 생성자에서 보모클래스의 생성자 호출
				//자식클래스에서는 반드시 부모클래스생성자가 호출 해야한다. 
				//이렇게 써줘야지 부모클래스 생성자도 초기화된다!없어도 컴파일러가 자동으로 호출해줌
				//부모클래스의 생성자에 파라미터가 있는경우에는 컴파일러자동호출이 불가하기에 직접호출필요.
	}
	
	//다형성
	public static void main(String[] args){
		SampleChild sc = new SampleChild();
		SampleParent sp = new SampleChild();
		//다형성 - 자식객체를 부모 변수에 넣어서 사용하는 것
		//sp = new SampleChild2();
		//sp - new SampleChild3();
		
		
		sc = (SampleChild)sp;
		sp = (SampleParent)sc;
		//자식타입 ->부모타입 형변환은 생략할 수 있다.
		
		//SampleChild sc2 = (SampleChild)new SampleParent(); //5개 = 2개기에 생략불가
		
		SampleParent sp2 = new SampleChild(); //2개 = 4개기에 생략가능.
		System.out.println(sp2.var);
		System.out.println(sp2.method(10, 20));
		
	
	}
	
}
