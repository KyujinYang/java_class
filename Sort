package d_array;

import java.util.Arrays;

public class Sort {

	public static void main(String[] args) {

		/*
		 * 
		 * 배열을 사용해서 로직을 만드는 것에 익숙해 지기 위한 연습
		 * 
		 * 석차구하기: 점수를 비교해 작은 점수의 등수를 증가시키는 방식 1등부터 꼴등까지 등수를 매기는 것 
		 * 선택정렬: 가장 작은 숫자를 찾아서 앞으로 보내는 방식 
		 * 버블정렬: 바로 뒤의 숫자와 비교해서 큰 수를 뒤로 보내는 방식 5 3 2 6
		 * 삽입정렬: 두번째 숫자부터 앞의 숫자들과 비교해서 큰수는 뒤로 밀고 중간에 삽입하는 방식
		 */

		int[] arr = new int[10];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = (int) (Math.random() * 100) + 1;

		}
		System.out.println(Arrays.toString(arr));


		// 여기까지 10개의 랜덤한 함수를 발생시킨 것 - 이 결과 값들이 점수라고 생각하기

		// 삽입정렬
		// 앞에 있는 수랑 비교를 해서 큰 수 만나면 뒤로 밀고 작은 만나면 삽입을 한다.
		// https://gmlwjd9405.github.io/2018/05/06/algorithm-insertion-sort.html
		// 여기에 개념이 잘 설명되어 있다.

		/*
		 * 1,0 2,1 2,0 3,2 3,1 3,0 4,3 4,2 4,1 4,0 5,4 5,3 5,2 5,1 5,0 6,5 6,4
		 * 6,3 6,2 6,1 6,0 7,6 7,5 7,4 7,3 7,2 7,1 7,0 8,7 8,6 8,5 8,4 8,3 8,2
		 * 8,1 8,0 9,8 9,7 9,6 9,5 9,4 9,3 9,2 9,1 9,0
		 */

		// 삽입정렬 - 선생님 답

		for (int i = 1; i < arr.length; i++) {
			int temp = arr[i];
			int j = 0;
			for (j = i - 1; j >= 0; j--) {
				if (arr[i] < arr[j]) {
					arr[j + 1] = arr[j];
					// j의 한칸 뒤가 i가 될 수 있음
					// 그렇게 되면 i가 없어질 수 있다.
					// 그래서 i값을 보존하기 위한 변수 temp를 만들어서 i를 보관함.
				} else {
					break;
					// 작은 값을 만나면 break로 for문을 빠져나온다.
				}

			}
			arr[j + 1] = temp; // j+1은 빈칸 - 컴파일 에러가 뜨니 j를 for안이 아닌 밖에서 선언해주었다.
		}
		System.out.println(Arrays.toString(arr));

		/*
		 * 정렬을 해주는 매서드도 있다. Arrays.sort(arr);
		 * 
		 * 다만 선택, 버블, 삽입 정렬에 포함되는 정렬이 아니라 퀵 정렬이라는 방법을 사용해서 정렬하는 매서드이다.지금까지 배운
		 * 내용으로는 만들 수가 없으니 퀵정렬 검색 한 번 해보기
		 */

		// 삽입정렬 - 지연 답
		/*
		 * for(int j = 1; j < arr.length ; j++) { for(int i = 0 ; i < j ; i++) {
		 * 
		 * if(arr[i] > arr[j]) { int temp = arr[i]; arr[i] = arr[j]; arr[j] =
		 * temp; }
		 * 
		 * } }
		 * 
		 * System.out.println(Arrays.toString(arr));
		 */
		/*
		 * // 삽입정렬 - 지연 풀이 // [29, 94, 25, 68, 1, 85, 43, 54, 11, 83]
		 * 
		 * if(arr[0] > arr[1]){
		 * 
		 * int temp = arr[0]; arr[0] = arr[1]; arr[1] = temp;
		 * 
		 * }
		 * 
		 * //[29, 94, 25, 68, 1, 85, 43, 54, 11, 83]
		 * 
		 * if(arr[1] > arr[2]){
		 * 
		 * int temp = arr[1]; arr[1] = arr[2]; arr[2] = temp; } //[29, 25, 94,
		 * 68, 1, 85, 43, 54, 11, 83]
		 * 
		 * if(arr[0] > arr[1]) { int temp = arr[1]; arr[1] = arr[2]; arr[2] =
		 * temp; }
		 * 
		 * //[25, 29, 94, 68, 1, 85, 43, 54, 11, 83]
		 * 
		 * 
		 * 
		 * 
		 * if(arr[2] > arr[3]){ int temp = arr[2]; arr[2] = arr[3]; arr[3] =
		 * temp; }
		 * 
		 * if(arr[1] > arr[2]){
		 * 
		 * int temp = arr[1]; arr[1] = arr[2]; arr[2] = temp; }
		 * 
		 * if(arr[0] > arr[1]) { int temp = arr[1]; arr[1] = arr[2]; arr[2] =
		 * temp; }
		 */

		// 버블정렬
		// 숫자를 두개씩 비교 -> 큰 수를 뒤로 보내는 것 -> 결국 오름차순 정렬이 된다.

		// 버블정렬은 중간에 끝날 수 있다!
		/*
		 * 
		 * 0,1 1,2 2,3 3,4 4,5 5,6 6,7 7,8 8,9 0,1 1,2 2,3 3,4 4,5 5,6 6,7 7,8
		 * 0,1 1,2 2,3 3,4 4,5 5,6 6,7 0,1 1,2 2,3 3,4 4,5 5,6 0,1 1,2 2,3 3,4
		 * 4,5 0,1 1,2 2,3 3,4 0,1 1,2 2,3 0,1 1,2 0,1
		 */

		/*
		 * //버블정렬 - 지연 풀이과정 if(arr[0] > arr[1]) { int temp = arr[0]; arr[0] =
		 * arr[1]; arr[1] = temp;
		 * 
		 * }
		 * 
		 * if(arr[1] > arr[2]) { int temp = arr[1]; arr[1] = arr[2]; arr[2] =
		 * temp;
		 * 
		 * }
		 */

		// 버블 정렬 - 지연 답

		/*
		 * for(int j = 1; j < arr.length; j++){
		 * 
		 * for(int i = 0; i < arr.length-1; i++){
		 * 
		 * if(arr[i] > arr[j]) { int temp = arr[i]; arr[i] = arr[j]; arr[j] =
		 * temp; }
		 * 
		 * } }
		 * 
		 * System.out.println(Arrays.toString(arr));
		 */

		/*
		 * //버블정렬 - 선생님 답 (버블 정렬은 한 바퀴 도는 동안 한 번도 움직이지 않으면 이미 정렬이 //끝났다고 생각하고
		 * 중간에 멈출 수가 있다. -> 그래서 그걸 설정 해주어야 한다)
		 * 
		 * boolean flag = true; for(int i =0; i < arr.length - 1; i++){ for(int
		 * j = 0 ; j < arr.length -1 -i; j++) { if(arr[j] > arr[j+1]){ int temp
		 * = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; flag = false; }
		 * 
		 * } if(flag){ break; } }
		 */
		// 선택정렬
		// 숫자 10개 중의 최솟값 찾아서 맨 앞에 있는 거랑 바꾸고 (오름차순(작은 수 -> 큰수) 정리) 나머지 9개 숫자랑
		// 비교해서 두번째 자리랑 바꾸고 ~~
		/*
		 * i, j 0,1 0,2 0,3 0,4 0,5 0,6 0,7 0,8 0,9 1,2 1,3 1,4 1,5 1,6 1,7 1,8
		 * 1,9 2,3 2,4 2,5 2,6 2,7 2,8 2,9 3,4 3,5 3,6 3,7 3,8 3,9 4,5 4,6 4,7
		 * 4,8 4,9 5,6 5,7 5,8 5,9 6,7 6,8 6,9 7,8 7,9 8,9
		 */

		/*
		 * 선택정렬 - 지연 풀이과정 int min = arr[0]; for(int i =0; i < arr.length; i++) {
		 * if(arr[i] < min){ //4일때 이 조건 충족 int temp = arr[0]; min = arr[i];
		 * arr[0] = arr[i]; arr[i] = temp;
		 * 
		 * } }
		 * 
		 * min = arr[1];
		 * 
		 * for(int i = 1; i < arr.length; i++){ if(arr[i] < min) { int temp =
		 * arr[1]; min = arr[i]; arr[1] = arr[i]; arr[i] = temp; } }
		 */

		// 선택정렬 - 지연 최종 답
		/*
		 * int min = arr[0];
		 * 
		 * for(int j = 0 ; j < arr.length-1; j++) { min = arr[j];
		 * 
		 * for(int i = j; i < arr.length; i++){ if(arr[i] < min) { int temp =
		 * arr[j]; min = arr[i]; arr[j] = arr[i]; arr[i] = temp; } }
		 * 
		 * 
		 * }
		 * 
		 * System.out.println(Arrays.toString(arr));
		 */

		// 선택정렬 - 선생님 답

		/*
		 * for(int i = 0; i < arr.length - 1; i++){ int min = i; for(int j = i +
		 * 1; j < arr.length; j++) //최솟값을 찾는 것이 아니라 최솟값이 들어있는 위치를 구해야 한다. //비교도
		 * 최솟값이 들어있는 위치와 해야 한다. { if(arr[j] < arr[min]) { min = j; } } int temp
		 * = arr[i]; arr[i] = arr[min]; arr[min] = temp; }
		 * 
		 * System.out.println(Arrays.toString(arr));
		 */

		// 석차구하기 - 선생님 답
		/*
		 * int[] rank = new int[arr.length]; for(int i =0; i < rank.length; i++)
		 * { rank[i] = 1; }
		 * 
		 * for(int i = 0 ; i < arr.length; i++){ for(int j = 0; j <arr.length;
		 * j++){ if(arr[i] < arr[j]) { rank[i]++; //더 작은 점수쪽의 등수를 플러스 해주어야 함. }
		 * 
		 * } } System.out.println(Arrays.toString(rank));
		 */

	}

}
